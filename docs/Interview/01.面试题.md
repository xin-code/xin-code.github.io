---
title: 面试题
date: 2022-03-29 17:08:15
sticky: true
permalink: /pages/cd5147/
categories: 
  - Interview
tags: 
  - Interview
author: 
  name: Xin
  link: https://github.com/xin-code
---

常见面试题

<!-- more -->

## 盒子模型
- "box-sizing": content-box（标准盒子模型）
  - width/height = content
- "box-sizing": border-box（IE盒子模型）
  - width/height = content + border + padding



## 如何利用Css画一个三角形
- 采用的是相邻边框连接处的均分原理
- 将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形

```
 #demo {
  "width": 0;
  "height": 0;
  "border-width": 20px; // 盒子模型的边框宽度
  "border-style": solid; // 边框的样式[none,dotted,dashed,solid]
  "border-color": transparent transparent red transparent; // 上 右 下 左
}
```



## rem、em、px区别
- px:是固定长度单位，不随其它元素的变化而变化
- em:就是根据基准来缩放字体大小em的值并不是固定的；em会根据父级元素的字体大小变化
- rem:是根据根元素`<html>`字体大小变化，这样就意味着，我们只需要在根元素确定一个参考值



## Css选择器
1. id选择器（#myid）
2. 类选择器（.myclassname）
3. 标签选择器（div,h1,p）
4. 后代选择器（h1 p）
5. 相邻后代选择器（子）选择器（ul>li）
6. 兄弟选择器（li~a）
7. 相邻兄弟选择器（li+a）
8. 属性选择器（a[rel="external"]）
9. 伪类选择器（a":hover,"li":nth-child）
10. 伪元素选择器（"::before、::after）
11. 通配符选择器（*）





## flex布局
1. flex-direction:排列方向  row | column | row-reserve | column-reserve
2. flex-wrap: 是否换行  wrap | nowrap | wrap-reserve
3. flex-flow:flex-direction&&flex-wrap简写模式  默认值为：row nowrap
4. justify-content:定义了主轴的对其方式  flex-start | flex-end | center | space-between | space-around
5. align-item:交叉轴上如何对齐 flex-start | flex-end | center | baseline | stretch





## 居中的方法
- 我们可以利用margin:0 auto来实现元素的水平居中。
- 利用绝对定位，先将元素的左上角通过top":50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心
- 利用绝对定位，先将元素的左上角通过top":50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心
- 使用flex布局，通过align-items":center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中





## HTTP常见的状态码
- 200-请求成功
- 202-服务器端已经收到请求消息，但是尚未进行处理 
- 301-永久移动、302-临时移动、304-所请求的资源未修改
- 400-客户端请求的语法错误、404-请求的资源不存在 
- 500-服务器内部错误





## JS数据类型
js 一共有六种基本数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）
还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型



## 原型链
- 构造函数：用来`new`的函数就叫构造函数



## ES6新特性
1. let 和 const
   - let：声明变量
   - const：声明常量

   

## 箭头函数和匿名函数







## 闭包







## 浅拷贝和深拷贝

1. 浅拷贝

   重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响

   - #### Object.assign()

   - #### 函数库lodash的_.clone方法

   - #### 展开运算符...

   - #### Array.prototype.concat()

   - #### Array.prototype.slice()

2. 深拷贝

   从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响

   - #### JSON.parse(JSON.stringify())

   - #### 函数库lodash的_.cloneDeep方法