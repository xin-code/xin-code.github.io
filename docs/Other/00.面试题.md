---
title: 面试题
date: 2022-03-29 17:08:15
sticky: true
permalink: /pages/cd5147/
categories:
  - Other
tags:
  -
author:
  name: Xin
  link: https://github.com/xin-code
---



## 盒子模型

- "box-sizing": content-box（标准盒子模型）
  - width/height = content
- "box-sizing": border-box（IE 盒子模型）
  - width/height = content + border + padding



## 如何利用 Css 画一个三角形

- 采用的是相邻边框连接处的均分原理
- 将元素的宽高设为 0，只设置 border，把任意三条边隐藏掉（颜色设为 transparent），剩下的就是一个三角形

```
 #demo {
  "width": 0;
  "height": 0;
  "border-width": 20px; // 盒子模型的边框宽度
  "border-style": solid; // 边框的样式[none,dotted,dashed,solid]
  "border-color": transparent transparent red transparent; // 上 右 下 左
}
```



## rem、em、px 区别

- px:是固定长度单位，不随其它元素的变化而变化
- em:就是根据基准来缩放字体大小 em 的值并不是固定的；em 会根据父级元素的字体大小变化
- rem:是根据根元素`<html>`字体大小变化，这样就意味着，我们只需要在根元素确定一个参考值



## Css 选择器

1. id 选择器（#myid）
2. 类选择器（.myclassname）
3. 标签选择器（div,h1,p）
4. 后代选择器（h1 p）
5. 相邻后代选择器（子）选择器（ul>li）
6. 兄弟选择器（li~a）
7. 相邻兄弟选择器（li+a）
8. 属性选择器（a[rel="external"]）
9. 伪类选择器（a":hover,"li":nth-child）
10. 伪元素选择器（"::before、::after）
11. 通配符选择器（\*）



## flex 布局

1. flex-direction:排列方向 row | column | row-reserve | column-reserve
2. flex-wrap: 是否换行 wrap | nowrap | wrap-reserve
3. flex-flow:flex-direction&&flex-wrap 简写模式 默认值为：row nowrap
4. justify-content:定义了主轴的对其方式 flex-start | flex-end | center | space-between | space-around
5. align-item:交叉轴上如何对齐 flex-start | flex-end | center | baseline | stretch



## 居中的方法

- 我们可以利用 margin:0 auto 来实现元素的水平居中。
- 利用绝对定位，先将元素的左上角通过 top":50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素的中心点到页面的中心
- 利用绝对定位，先将元素的左上角通过 top":50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素的中心点到页面的中心
- 使用 flex 布局，通过 align-items":center 和 justify-content:center 设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中



## Cookie和Session的区别和联系

> `Session`比`Cookie`安全，Session是存储在服务器端的，Cookie是存储在客户端的

1. `Cookie`存储在客户端，`Session`存储在服务器上
2. `Cookie`不是很安全，可以分析本地的`Cookie`进行**cookie欺骗**
3. `session`会在一定时间内保存在服务器上，当访问增多，会比较**占用服务器的性能**



## HTTP 常见的状态码

- 200-请求成功
- 202-服务器端已经收到请求消息，但是尚未进行处理
- 301-永久移动、302-临时移动、304-所请求的资源未修改
- 400-客户端请求的语法错误、404-请求的资源不存在
- 500-服务器内部错误



## JS 数据类型

js 一共有六种基本数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）
还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型



## JS 延迟加载的方法

1. `<script async src="./script.js"></script>`给Script标签添加**async**属性，则加载和渲染后续文档元素和js文件异步进行
2. `<script defer src="./script.js"></script>`给Script标签添加**defer**属性，js文件执行在所有元素解析完之后，DOMContentLoaded事件触发之前完成
3. setTimeout定时器延迟代码执行



## 原型链

- 构造函数：用来`new`的函数就叫构造函数



## ES6 新特性

1. let 和 const

   一、首先补充知识：**var**

    （1）可以重复声明

   ```javascript
   var a = 10;
   var a = 2;
   console.log(a); // 结果为2
   ```

    （2）不可定义常量（所谓常量，就是一旦被定义则无法被修改），var 定义的可以再次被修改，参考（1）

    （3）没有块级作用域

   ```javascript
   if (true) {
     var a = 123;
   }
   console.log(a); // 结果为123
   ```

    （4）会预解释（变量提升）

   ```javascript
   console.log(a); //undefined相当于 var a 预解释
   var a = 52;
   ```

   二、**let** 定义变量

    （1）不能重复声明

   ```javascript
   let a = 5;
   let a = 10;
   console.log(a); //这时候就会出现报错，因为相同的变量不能声明两次
   ```

    （2）可以修改（let 是定义变量，可以随时修改值）

   ```javascript
   let a = 5;
   a = 10;
   console.log(a); // 结果为10
   ```

    （3）有块级作用域

   ```javascript
   if (true) {
     let a = 123;
   }
   console.log(a); // 这个时候就会出现报错，说a没有定义
   ```

    （4）不会预解释（不会变量提升）

   ```javascript
   console.log(a); //Uncaught ReferenceError: a is not defined 语法错误，没有预解释
   let a = 123;
   ```

   三、**const** 定义常量

    （1）不能重复声明

   ```javascript
   const a = 5;
   const a = 10;
   console.log(a); // 这个时候就会出现报错，因为相同的变量不能声明两次
   ```

    （2）不能修改（const 是定义常量，是不能修改的）

   ```javascript
   const a = 5;
   a = 10;
   console.log(a); // 这时候就会出现报错，不能修改
   ```

    （3）有块级作用域

   ```javascript
   if (true) {
     const a = 123;
   }
   console.log(a); // 这个时候就会出现报错，说a没有定义
   ```

    （4）不会预解释（不会变量提升）

   ```javascript
   console.log(a); //Uncaught ReferenceError: a is not defined 语法错误，没有预解释
   const a = 123;
   ```

   :star:总结:star::

   1、在重复声明方面，var 可以重复定义，let 和 const 不可以重复定义，否则报错。

   2、const 常量则不可修改

   3、在作用域方面，var 是函数作用域，let 和 const 则是块级作用域

   4、在变量提升方面，var 声明不论在何处，都会被视为声明在函数最顶部，let 和 const 则不会变量提升

2. 模板字符串

3. 箭头函数

   - 区分`箭头函数`和`普通函数`

     - 箭头函数不能作为构造函数，不能使用new

     - 箭头函数没有自己的this

       取决于函数外部非箭头函数的this值，如果上一级还是箭头函数，继续往上找，如果找不到，那么this就是window对象

     - 箭头函数没有原型对象（**prototype**）

     - 箭头函数没有参数（**arguments**）

     

   - 区分`箭头函数`和`匿名函数`

     - 

4. 解构赋值

   - **数组**的解构

     - **按次序排列**
     - 可以从数组中提取值，按照对应位置，对变量赋值,这种写法属于**模式匹配**
     - 可以使用 `...`进行解构，代表剩余全部
     - 如果原数组没有，则在对应值上可设置默认值，如果不设置，则为`undefined`

     ```javascript
      let [a, b, c] = [1, 2, 3]
      console.log(a, b, c) // 1 2 3

      let [a, , c] = [1, 2, 3]
      console.log(a, , c) // 1 3

      let [a, b, ...c] = [1, 2, 3, 4, 5]
      console.log(a, b, c) // 1 2 [3, 4, 5]

      let [a, b, ...c] = [1]
      console.log(a, b, c) // 1 undefined []

      let [a = 1, b = a] = []
      console.log(a, b) // 1 1

      let [a = 1, b = a] = [2]
      console.log(a, b) // 2 2
     ```

   - **对象**的解构

     - **无次序行，只需变量与属性名同名即可**
     - 如果变量和对象的属性名没有重复，则会导致变量的值为`undefined`
     - 注意`:`,他相当于别名:exclamation:

     ```javascript
     let { a, b } = { a: 1, b: 2 };
     console.log(a, b); // 1 2

     let { a } = { b: 2 };
     console.log(a); // undefined

     let { a, b = 2 } = { a: 1 };
     console.log(a, b); // 1 2

     let { a: b = 2 } = { a: 1 };
     console.log(a); // 不存在 a 这个变量
     console.log(b); // 1
     ```

   let { a, b:b2 } = { a: 1, b: 2 }; // b 的别名改为 b2
   console.log(a, b2); // 1,2

   ```
   
   ```



   ```

5. 正则扩展

   正则表达式分为两种风格

   1. **JS 风格**：RegExp()

      ```javascript
      let re = new RegExp("a"); //查找一个字符串内是否有a
      let re = new RegExp("a", "i"); //第一个是查找的对象，第二个是选项
   ```

   2. **prel 风格**：/规则/

      ```javascript
      let re = /a/; //查找一个字符串内是否有a
      let re = /a/i; //第一个是查找的对象，第二个是选项
      ```

6. 字符串扩展

   - **padStart()**：把指定字符串填充到字符串头部，返回新字符串
   - **padEnd()**：把指定字符串填充到字符串尾部，返回新字符串

7. 数组扩展

   - **扩展运算符（...）**

     ```javascript
     let a = [1, 2, 3];
     let b = [1, 2, 4];
     console.log([...new Set([...a, ...b])]); // [1,2,3,4]
     ```

8. 对象扩展

   - **Object.values()**：返回以值组成的数组
   - **Object.entries()**：返回以键和值组成的数组

9. 可选链操作符（"?."）

   ```javascript
   let id = user.info && user.info.id

   => 可以简写成 let id = user.info?.id
   ```

10. 空值合并运算符（"??"）

    ```javascript
    a ?? b 的结果是：

    // 如果 a 是已定义的，则结果为 a
    // 如果 a 不是已定义的，则结果为 b

    等同于：(a !== null && a !== undefined) ? a : b
    ```



## 闭包

概念：闭包就是指有权访问另一个函数作用域中的变量的函数

通俗来讲：就是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放。就导致上级作用域内的变量，等到下级作用域执行完以后才正常得到释放。



## 浅拷贝和深拷贝

1. 浅拷贝

   浅拷贝只复制指向某个对象的指针，而不复制对象本身，**新旧对象还是共享同一块内存**，会相互影响

   - Object.assign()
   - （es6 新特性）展开运算符...与 Object.assign()的功能相同
   - 函数库 lodash 的\_.clone 方法（Shallow Copy）
   - Array.prototype.concat()
   - Array.prototype.slice()

2. 深拷贝

   深拷贝会另外创造一个一模一样的对象，**新对象跟原对象不共享内存**，修改新对象不会改到原对象

   - JSON.parse(JSON.stringify())，不能深拷贝正则（变为空对象），不能拷贝函数（变为 null）
   - 函数库 lodash 的\_.cloneDeep 方法



## 防抖&节流

|       操作        | 描述                                                   | 场景                                                                      |
| :---------------: | ------------------------------------------------------ | ------------------------------------------------------------------------- |
| 防抖（debounce）  | 频繁去触发一个事件，但是只触发最后一次。以最后一次为准 | 1、input 框变化频繁触发事件可加防抖 <br />2、频繁点击按钮提交表单可加防抖 |
| 节流 （throttle） | 频繁去触发一个事件，但是只能每隔一段时间触发一次       | 1、滚动频繁请求列表可加节流                                               |

- 防抖

  :round_pushpin: 【原理】：主要是利用一次性定时器，延迟任务的执行，在延迟这段时间内，如果任务再次被触发，则通过 clearTimeout 销毁上次产生的定时器，因为定时器的被销毁，之前被延迟执行的任务相应的被取消执行。这样就实现了在一定时间内，只执行一次任务，以最后一次触发为准。

  ```javascript
  function debounce(fn, delay = 200) {
    let timer = 0;
    return function () {
      // 如果这个函数已经被触发了
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        fn.apply(this, arguments); // 透传 this和参数
        timer = 0;
      }, delay);
    };
  }
  ```

- 节流

  :round_pushpin:【原理】：每隔一段时间执行一次函数。

```javascript
// 节流函数
function throttle(fn, delay = 200) {
  let timer = 0;
  return function () {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments); // 透传 this和参数
      timer = 0;
    }, delay);
  };
}
```

- 利用`lodash`使用方法

```vue
<script>
import debounce from "lodash/debounce";
import throttle from "lodash/throttle";
import dayjs from "dayjs";
export default {
  data() {
    return {};
  },
  watch: {},
  methods: {
    // 防抖处理的input
    debounceInput: debounce(function (val) {
      console.log(dayjs().format("HH:mm:ss"), val);
    }, 500),
    // 节流处理的input
    throttleInput: throttle(function (val) {
      console.log(dayjs().format("HH:mm:ss"), val);
    }, 1000),
  },
};
</script>
```





## 高阶函数

普通函数都是以变量的形式传递参数，如果可以接受另一个函数作为参数的话，那么就称这个函数为高阶函数

```javascript
// 简单的高阶函数
function add(x, y, f) {
    return f(x) + f(y);
}

//用代码验证一下：
add(-5, 6, Math.abs); // 11
```





## 跨域

1. 是什么

   是浏览器的同源策略的一种安全手段

2. 同源是指：:one:协议相同（protocol）:two:主机相同（host）:three:端口相同（port）

   如果其中一项不相同的时候，就产生了跨域

3. 如何解决

   - JSONP
   
   - CORS
   
     - 【Cross-Origin Resource Sharing，跨域资源共享】，实现起来很简单，添加一些HTTP头，让服务器允许访问来源即可，只要后端实现即可
   
   - Proxy
   
     - 代理
   
       通过**vue-cli**脚手架搭建项目后，可以通过`webpack`起一个本地服务器作为请求的代理对象。通过该服务器请求至目标服务器，结果在传回前端
   
       在`vue.config.js`文件中添加

```javascript
module.exports = {
    devServer: {
        host: '127.0.0.1',
        port: 8084,
        open: true,// vue项目启动时自动打开浏览器
        proxy: {
            '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
                target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
                changeOrigin: true, //是否跨域
                pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                    '^/api': "" 
                }
            }
        }
    }
}
```

通过`axios`发送请求中，配置请求的根路径

```javascript
axios.defaults.baseURL = '/api'
```

