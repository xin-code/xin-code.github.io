---
title: Vue2
date: 2022-03-24 16:13:37
permalink: /pages/vue2/
categories: 
  - Vue2
tags: 
  - 
author: 
  name: Xin
  link: https://github.com/xin-code
---


Vue易混知识点以及部分遗漏知识进行的梳理总结

<!-- more -->



## 使用sort报错

>  `You may have an infinite update loop in a component render function(意思是：组件渲染函数中可能有一个无限更新循环)`

解决办法:

 ```javascript
return values.slice().sort(...)
 ```





## 指令

### v-if / v-show

- v-if 

  - v-if="true" 插入元素
  - v-if="false"移除元素
  - 会摧毁整个dom元素整个添加或删除

- v-show

  - v-show="true" 显示
  - v-show="false"隐藏
  - 本质上是为该dom元素添加一个css属性并基于 `display`进行切换

- 消耗方面：v-if有更高的切换消耗，v-show有更高的初始渲染消耗

  （v-if 相比 v-show 开销更大的（因为直接操作dom节点增加与删除））



## import '@...' 中@指代

- @ 等价于 `/src` 这个目录，避免写麻烦又易错的相对路径



## 缩写

```vue
:class 等效于 v-bind:class
@click 等效于 v-on:click
<template #footer 等效于 <template v-slot:footer
```



## .native修饰符的使用

- 在 v-on （@）上使用的修饰符 .native 给子组件绑定一个原生的事件

  ```vue
  @keyup.enter.native="save"  // 回车触发事件 'save'
  @click.native="onClickDetail" // 点击触发事件 'onClickDetail'
  ```

  

## 具名插槽

- 父组件

  - 一个不带 `name` 的 `<slot>` 出口会带有隐含的名字“default”。

  ```vue
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  ```

  

- 子组件

  ```vue
  <div>
    <template v-slot:header>
    <!-- 可缩写为#header -->
    <template #header>
      <h1>Here might be a page title</h1>
    </template>
    </template>
  
    <template v-slot:default>
    <!-- 可缩写为#default -->
    <template #default>
      <p>A paragraph for the main content.</p>
      <p>And another one.</p>
    </template>
    </template>
  
    <template v-slot:footer>
    <!-- 可缩写为#footer -->
    <template #footer>
      <p>Here's some contact info</p>
    </template>
    </template>
  </div>
  ```

  



## this.$set( target, key, value )

- 使用场景：向响应式对象新增一个属性，并确保这个新属性同样是响应式的，可以触发视图更新
- 当使用watch方法时，可以用这个触发视图更新

```vue
🌹 target：要更改的数据源(可以是对象或者数组)
🌹 key：要更改的具体数据(index值)
🌹 value ：重新赋的值
```



## 页面监控鼠标点击事件

1. 添加监听

   ```vue
   mounted () {
       window.addEventListener('click', this.handleClick, true);
   },
   ```

2. 方法调用

   ```vue
   methods:{
       //  点击事件
       handleClick(e){
           console.log(e)
       },
   }
   ```

3. 移除监控

   ```vue
     destroyed() {
       window.removeEventListener('click', this.handleClick, true);
     },
   ```




## 下载文件

- 文件流

  ```javascript
      let elink = document.createElement('a');
  	// 根据后端返回的名字命名
  	let name = res.headers['content-disposition'];
  	const fileName = `${decodeURI(name.split(';')[1].split('=')[1])}`;
      elink.download = `${fileName}`;
      elink.style.display = 'none';
      let blob = new Blob([res]);
      elink.href = URL.createObjectURL(blob);
      document.body.appendChild(elink);
      elink.click();
      document.body.removeChild(elink);
  ```

- 文件链接

  ```javascript
        let link = document.createElement('a');
        link.style.display = 'none';
        link.href = 'xxxx.doc';
        link.setAttribute('download', name);
        document.body.appendChild(link);
        link.click();
  ```




## 下载文件打不开

- 解决办法:

  - 在请求时添加

  ```javascript
  responseType: 'blob'
  ```

  



## mixins

mixins（混入），是一个js对象，它可以包含我们组件中script项中的任意功能选项，如data、components、methods 、created、computed等等。我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来，这样就可以提高代码的重用性，使你的代码保持干净和易于维护。

```vue
<script>
export default {
  props: {
  },
  data () {
    return {
      pagination: {
        list: [], // 分页数据(required)
        currentPage: 1, // 当前页码(required)
        total: 0, // 总数(required)
        pageSize: 50, // 分页数设定值
        size: 0, // 分页数实际值(比如设定pageSize为10，但最后一页只有7条记录，size为7)
        pages: 1, // 总页数
        startRow: 0, // 当前起始索引
        endRow: 0, // 当前结尾索引
      },
    }
  },
  computed: {
  },
  methods: {
    // 公共方法 翻页
    togglePage (page) {
      this.pagination.currentPage = page
      this.query()
    },
    // 公共方法 分页大小修改
    changePageSize (pageSize) {
      this.pagination.pageSize = pageSize
      this.query()
    },
  },
}
</script>
<style lang="scss" rel="stylesheet/scss" scoped>
</style>

```



- 使用

```vue
<template>
  <div class="flex-column flex-ai-stretch">
    <operation
      @query="query"
      class="flex-none"
    />
    <data-table
      :pagination="pagination"
      @togglePage="togglePage"
      @changePageSize="changePageSize"
      class="flex-auto"
    />
  </div>
</template>

<script>
import PagingData from '@/components/pagination/PagingData'
import Operation from './Operation'
import DataTable from './DataTable'
import * as adApi from '@/api/ad-api/ad'

export default {
  // 混入 PagingData
  mixins: [PagingData],
  components: {
    Operation,
    DataTable,
  },
  props: {},
  data () {
    return {
      queryParams: null,
    }
  },
  computed: {},
  methods: {
    async query (queryParams) {
      if (queryParams) {
        // 查询条件有变动，页码归零
        this.queryParams = queryParams
        this.pagination.currentPage = 1
      }
      // 封装的API方法
      const res = await adApi.listChildren(this.queryParams, this.pagination)
      Object.assign(this.pagination, res)
    },
  },
  watch: {},
  created () {},
}
</script>

<style lang="scss" scoped>

</style>

```



## v-on="$listeners" 【自下向上传递事件】

@click 等效于 v-on:click (事件)

父、子、孙 隔代通讯中使用

孙（$emit）→子（$emit）→父，要使用两次$emit 传递事件，才能传递到`父`组件

在中间组件【子组件】中使用即可，省去再次传递的过程

```vue
<template>
  <Son v-on="$listeners"/>
</template>
```

父组件直接可以直接使用@方法名

```vue
<template>
  <Father @Msg='Msg'/>
</template>
 
methods:{
  Msg(val){
    console.log(val) //从孙组件($emit)传递过来的方法
  }
}
```



## v-bind="$attrs" 【自上向下传递值】

:class 等效于 v-bind:class (传值)

父、子、孙 隔代通讯中使用

父（:content="内容"）→子（:content="内容"）→孙，要使用两次content，才能传递到`孙`组件

在中间组件【子组件】中使用即可，省去再次传递的过程

```vue
<template>
  <Son v-bind="$attrs"/>
</template>
```

孙组件直接props接收即可

```vue
<template>
  <div>父传递过来的值:{{content}}</div>
</template>
 
<script>
export default {
  name: 'grandson',
  props: {
    content:{ //接收父传递的content
      type:String,
      default:''
    }
  },
}
</script>
```



## EventBus

<font color='red'>事件总线</font>，相当于一个全局的仓库，任何组件都可以去这个仓库里获取事件。主要用于组件之间的传值，例如：兄弟传值

1、在main.js中全局初始化`EventBus`

```vue
Vue.prototype.$EventBus = new Vue()
```

2、在A组件中向`EventBus`发送事件

```vue
this.$EventBus.$emit("msg", '123');
```

3、在B组件中接收事件

```vue
 mounted() {
    this.$EventBus.$on("msg", (data) => {
      this.msg = data;
    });
 }
```

4、移除监听

上述三步中A组件向B组件进行传递了数据，但当离开B组件再次进入B组件时，时间总线里就有多个监听，会导致事件只触发了一次，但监听事件中的回调函数执行了很多次，所以在组件离开前，也就是被销毁前，需要将该监听事件给移除，以免下次再重复创建监听。

```vue
// 离开B组件的时候移除
beforeDestroy(){
    //移除监听事件"msg"
    this.$EventBus.$off("msg")
}
```





## Vuex

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

- state

  关键词:`单一状态树`,`存储`,`共享数据`

  <span style="color:red">使用:</span>

  - this.$store.state['属性名']

  - ```vue
    import { mapState } from 'vuex'
    
    computed: {
        ...mapState({
    	// 写法一:箭头函数 可以重命名名称为xxa
          xxa: state => state.xx,
    	// 写法二:传字符串等同于 state => state.aa,
    	  aa:'aa',
        }),
    	// 写法三:缩写，在无需重命名的情况下，直接可以使用state里的名称
       ...mapState(['ccc']),
    }
    ```

- getters

  关键词:`计算属性`,`公共函数`,`state发生变化重新计算`

  - vuex中使用

    ```
    getters: {
      	// 第一个参数 state
        getName: (state) => {
          return state.name ? '李四' : '王五'
        }
        // state 和 getters
        getNameType: (state,getters) => {
        	return typeof getters.getName
        }
        // 可以传递用户自定义的值 让函数返回另一个函数
        getNameDefault (state) {
          return function (name) {
            return state.name ? name : 'xxx'
          }
        }
      },
    ```
  
    
  
  <span style="color:red">使用:</span>
  
  - this.$store.getters['属性名']
  
  - ```vue
    import { mapGetters } from 'vuex'
    
    computed: {
        ...mapState({
    	// 写法一:重命名的情况下aab
    	  aab:'aa',
        }),
    	// 写法二:缩写，计算属性的名称与 getters 的子节点名称，无需重命名的情况下。
       ...mapState(['ccc']),
    }
    ```
  



- mutations

  关键词:`改变state中状态的唯一方法`，`处理数据逻辑`

  - vuex中使用

  ```vue
    mutations: {
      // 默认第一个参数为state 第二个为payload(载荷)
      changeName (state, name) {
        state.name = name
      },
      changeAge (state, age) {
        state.age = age
      },
  	// 可以同时修改两个数据
      changeUserInfo (state, info) {
        this.commit('changeName',info.name)
        this.commit('changeAge',info.age)
      }
    },
  ```

  <span style="color:red">使用:</span>

  - this.$store.commit('xxx',[xxx])

  - ```vue
    import { mapMutations } from 'vuex'
    
    methods: {
    	// 更新 vuex state
    	// 可以直接调用方法
    	...mapMutations(['changeName','changeUserInfo']),
    	
    	// 单个用户信息
    	onClickChangeName(){
    		// 直接调用mutations方法
    		this.changeName('AAA')
    	},
    	
    	changeUserInfo(){
    		// 改变用户信息
    		this.changeUserInfo({
    			name:'YYY',
    			age:99,
    		})
    	}
    }
    ```



- actions

  关键词:`异步`,`提交给mutation`

- modules

  关键词:`分割`,`模块`



## Vuex持久化插件

- 当页面刷新后，Vuex数据会清空

```shell
npm i vuex-persistedstate
```

- 在Vuex页面 添加`plugins`

```vue
export default new Vuex.Store({
  state: {
  },
  getters: {
  },
  mutations: {
  },
  actions: {
  },
  modules: {
  },
  plugins: [createPersistedState()]
})
```







## 代码打包

- source Map

  一个信息文件，用于存储代码行的位置，在压缩代码后，浏览器依然可以显示原始代码行的位置

  ```js
  文件:vue.config.js
  module.exports = {
      productionSourceMap: false, // 不使用sourceMap 提高构建速度
      productionSourceMap: true, // 使用sourceMap 报错后可以定位原始代码行位置
  }
  ```






## F12 不显示Vue插件

1. F12不显示Vue插件 并且 点击扩展程序显示 'Devtools inspection is not available because it's in production mode or explicitly disabled by the author.'
2. 可能Vue不是生产环境或者压缩版

- 可以在`main.js`文件中添加

  ```javascript
  Vue.config.devtools = true;
  ```

- 刷新网页即可显示